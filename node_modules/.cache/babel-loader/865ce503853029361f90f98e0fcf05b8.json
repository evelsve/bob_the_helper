{"ast":null,"code":"import _objectSpread from \"/Users/evelsve/repos/react-xstate-colourchanger/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { send, assign } from \"xstate\";\nimport { say, promptAndAsk } from \"./index\";\nimport { loadGrammar } from './runparser';\nimport { parse } from './chartparser';\nimport { grammar } from './grammars/orderGrammar';\nconst gram = loadGrammar(grammar);\nexport const getRuleObj = input => {\n  const gram = loadGrammar(grammar);\n  const prs = parse(input.split(/\\s+/), gram);\n  const result = prs.resultsForRule(gram.$root)[0];\n  const reply = \"action to perform is, \" + result.order.action + \". on object, \" + result.order.object;\n  return reply;\n}; // <tag>out.order= new Object(); out.order.object = rules.order.entity; out.order.event = rules.order.action; out.order.transition=rules.order.transition;</tag>\n\nexport const dmMachine4 = {\n  initial: 'idle',\n  states: {\n    idle: {},\n    welcome: {\n      initial: \"prompt\",\n      on: {\n        ENDSPEECH: \"task\"\n      },\n      states: {\n        prompt: {\n          entry: say(\"Welcome to Smart Home\")\n        }\n      }\n    },\n    task: _objectSpread({\n      initial: \"prompt\",\n      on: {\n        RECOGNISED: {\n          target: 'perform',\n          actions: assign(context => {\n            return {\n              order: Order(context.recResult)\n            };\n          })\n        }\n      }\n    }, promptAndAsk(\"I await for your orders.\")),\n    perform: {\n      initial: \"prompt\",\n      states: {\n        prompt: {\n          entry: send(context => ({\n            type: \"SPEAK\",\n            value: \"OK \".concat(context.order, \".\")\n          }))\n        }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/evelsve/repos/react-xstate-colourchanger/src/dmSmartHome.ts"],"names":["send","assign","say","promptAndAsk","loadGrammar","parse","grammar","gram","getRuleObj","input","prs","split","result","resultsForRule","$root","reply","order","action","object","dmMachine4","initial","states","idle","welcome","on","ENDSPEECH","prompt","entry","task","RECOGNISED","target","actions","context","Order","recResult","perform","type","value"],"mappings":";AAAA,SAAwBA,IAAxB,EAA8BC,MAA9B,QAA4C,QAA5C;AACA,SAAQC,GAAR,EAAqBC,YAArB,QAAyC,SAAzC;AACA,SAASC,WAAT,QAA4B,aAA5B;AACA,SAASC,KAAT,QAAsB,eAAtB;AACA,SAASC,OAAT,QAAwB,yBAAxB;AAEA,MAAMC,IAAI,GAAGH,WAAW,CAACE,OAAD,CAAxB;AAEA,OAAO,MAAME,UAAU,GAAIC,KAAD,IAAmB;AACzC,QAAMF,IAAI,GAAGH,WAAW,CAACE,OAAD,CAAxB;AACA,QAAMI,GAAG,GAAGL,KAAK,CAACI,KAAK,CAACE,KAAN,CAAY,KAAZ,CAAD,EAAqBJ,IAArB,CAAjB;AACA,QAAMK,MAAM,GAAGF,GAAG,CAACG,cAAJ,CAAmBN,IAAI,CAACO,KAAxB,EAA+B,CAA/B,CAAf;AACA,QAAMC,KAAK,GAAG,2BAAyBH,MAAM,CAACI,KAAP,CAAaC,MAAtC,GAA6C,eAA7C,GAA+DL,MAAM,CAACI,KAAP,CAAaE,MAA1F;AACA,SAAOH,KAAP;AACH,CANM,C,CASP;;AACA,OAAO,MAAMI,UAAoD,GAAI;AACjEC,EAAAA,OAAO,EAAE,MADwD;AAEjEC,EAAAA,MAAM,EAAE;AACJC,IAAAA,IAAI,EAAE,EADF;AAEJC,IAAAA,OAAO,EAAE;AACLH,MAAAA,OAAO,EAAE,QADJ;AAELI,MAAAA,EAAE,EAAE;AAAEC,QAAAA,SAAS,EAAE;AAAb,OAFC;AAGLJ,MAAAA,MAAM,EAAE;AACJK,QAAAA,MAAM,EAAE;AAAEC,UAAAA,KAAK,EAAEzB,GAAG,CAAC,uBAAD;AAAZ;AADJ;AAHH,KAFL;AASJ0B,IAAAA,IAAI;AACAR,MAAAA,OAAO,EAAE,QADT;AAEAI,MAAAA,EAAE,EAAE;AACAK,QAAAA,UAAU,EAAE;AACRC,UAAAA,MAAM,EAAE,SADA;AAGRC,UAAAA,OAAO,EAAE9B,MAAM,CAAE+B,OAAD,IAAa;AAAC,mBAAO;AAAEhB,cAAAA,KAAK,EAAEiB,KAAK,CAACD,OAAO,CAACE,SAAT;AAAd,aAAP;AAA4C,WAA3D;AAHP;AADZ;AAFJ,OASG/B,YAAY,CAAC,0BAAD,CATf,CATA;AAoBJgC,IAAAA,OAAO,EAAE;AACLf,MAAAA,OAAO,EAAE,QADJ;AAELC,MAAAA,MAAM,EAAE;AACJK,QAAAA,MAAM,EAAE;AACJC,UAAAA,KAAK,EAAE3B,IAAI,CAAEgC,OAAD,KAAc;AACtBI,YAAAA,IAAI,EAAE,OADgB;AAEtBC,YAAAA,KAAK,eAAQL,OAAO,CAAChB,KAAhB;AAFiB,WAAd,CAAD;AADP;AADJ;AAFH;AApBL;AAFyD,CAA9D","sourcesContent":["import { MachineConfig, send, assign } from \"xstate\";\nimport {say, listen, promptAndAsk } from \"./index\";\nimport { loadGrammar } from './runparser'\nimport { parse } from './chartparser'\nimport { grammar } from './grammars/orderGrammar'\n\nconst gram = loadGrammar(grammar)\n\nexport const getRuleObj = (input: string) => {\n    const gram = loadGrammar(grammar);\n    const prs = parse(input.split(/\\s+/), gram);\n    const result = prs.resultsForRule(gram.$root)[0]\n    const reply = \"action to perform is, \"+result.order.action+\". on object, \" + result.order.object;\n    return reply\n}\n\n\n// <tag>out.order= new Object(); out.order.object = rules.order.entity; out.order.event = rules.order.action; out.order.transition=rules.order.transition;</tag>\nexport const dmMachine4: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    states: {\n        idle: {},\n        welcome: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"task\" },\n            states: {\n                prompt: { entry: say(\"Welcome to Smart Home\") }\n            }\n        },\n        task: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: {\n                    target: 'perform',\n                    \n                    actions: assign((context) => {return { order: Order(context.recResult) } })\n                        }\n                    },\n            ...promptAndAsk(\"I await for your orders.\")\n        },\n        perform: {\n            initial: \"prompt\",\n            states: {\n                prompt: { \n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK ${context.order}.`\n                    }))\n                }\n            }\n        }\n    }\n})"]},"metadata":{},"sourceType":"module"}