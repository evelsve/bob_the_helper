{"ast":null,"code":"import _objectSpread from \"/Users/evelsve/repos/react-xstate-colourchanger/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { send, assign } from \"xstate\";\nimport { say, promptAndAsk } from \"./index\";\nimport { loadGrammar } from './runparser';\nimport { parse } from './chartparser';\nimport { grammar } from './grammars/orderGrammar';\nconst gram = loadGrammar(grammar);\n\nconst Order = input => {\n  const gram = loadGrammar(grammar);\n  const prs = parse(input.split(/\\s+/), gram);\n  const result = prs.resultsForRule(gram.$root)[0]; // const reply = console.log(result)\n\n  return result;\n}; // <tag>out.order= new Object(); out.order.object = rules.order.entity; out.order.event = rules.order.action; out.order.transition=rules.order.transition;</tag>\n\n\n_c = Order;\nexport const dmMachine4 = {\n  initial: 'idle',\n  states: {\n    idle: {},\n    welcome: {\n      initial: \"prompt\",\n      on: {\n        ENDSPEECH: \"task\"\n      },\n      states: {\n        prompt: {\n          entry: say(\"Welcome to Smart Home\")\n        }\n      }\n    },\n    task: _objectSpread({\n      initial: \"prompt\",\n      on: {\n        RECOGNISED: {\n          target: 'perform',\n          actions: assign(context => {\n            return {\n              order: Order(context.recResult)\n            };\n          })\n        }\n      }\n    }, promptAndAsk(\"I await for your orders.\")),\n    perform: {\n      initial: \"prompt\",\n      states: {\n        prompt: {\n          entry: send(context => ({\n            type: \"SPEAK\",\n            value: \"OK \".concat(context.order, \".\")\n          }))\n        }\n      }\n    }\n  }\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"Order\");","map":{"version":3,"sources":["/Users/evelsve/repos/react-xstate-colourchanger/src/dmSmartHome.ts"],"names":["send","assign","say","promptAndAsk","loadGrammar","parse","grammar","gram","Order","input","prs","split","result","resultsForRule","$root","dmMachine4","initial","states","idle","welcome","on","ENDSPEECH","prompt","entry","task","RECOGNISED","target","actions","context","order","recResult","perform","type","value"],"mappings":";AAAA,SAAwBA,IAAxB,EAA8BC,MAA9B,QAA4C,QAA5C;AACA,SAAQC,GAAR,EAAqBC,YAArB,QAAyC,SAAzC;AACA,SAASC,WAAT,QAA4B,aAA5B;AACA,SAASC,KAAT,QAAsB,eAAtB;AACA,SAASC,OAAT,QAAwB,yBAAxB;AAEA,MAAMC,IAAI,GAAGH,WAAW,CAACE,OAAD,CAAxB;;AAEA,MAAME,KAAK,GAAIC,KAAD,IAAmB;AAC7B,QAAMF,IAAI,GAAGH,WAAW,CAACE,OAAD,CAAxB;AACA,QAAMI,GAAG,GAAGL,KAAK,CAACI,KAAK,CAACE,KAAN,CAAY,KAAZ,CAAD,EAAqBJ,IAArB,CAAjB;AACA,QAAMK,MAAM,GAAGF,GAAG,CAACG,cAAJ,CAAmBN,IAAI,CAACO,KAAxB,EAA+B,CAA/B,CAAf,CAH6B,CAI7B;;AACA,SAAOF,MAAP;AACH,CAND,C,CASA;;;KATMJ,K;AAUN,OAAO,MAAMO,UAAoD,GAAI;AACjEC,EAAAA,OAAO,EAAE,MADwD;AAEjEC,EAAAA,MAAM,EAAE;AACJC,IAAAA,IAAI,EAAE,EADF;AAEJC,IAAAA,OAAO,EAAE;AACLH,MAAAA,OAAO,EAAE,QADJ;AAELI,MAAAA,EAAE,EAAE;AAAEC,QAAAA,SAAS,EAAE;AAAb,OAFC;AAGLJ,MAAAA,MAAM,EAAE;AACJK,QAAAA,MAAM,EAAE;AAAEC,UAAAA,KAAK,EAAErB,GAAG,CAAC,uBAAD;AAAZ;AADJ;AAHH,KAFL;AASJsB,IAAAA,IAAI;AACAR,MAAAA,OAAO,EAAE,QADT;AAEAI,MAAAA,EAAE,EAAE;AACAK,QAAAA,UAAU,EAAE;AACRC,UAAAA,MAAM,EAAE,SADA;AAERC,UAAAA,OAAO,EAAE1B,MAAM,CAAE2B,OAAD,IAAa;AAAC,mBAAO;AAAEC,cAAAA,KAAK,EAAErB,KAAK,CAACoB,OAAO,CAACE,SAAT;AAAd,aAAP;AAA4C,WAA3D;AAFP;AADZ;AAFJ,OAQG3B,YAAY,CAAC,0BAAD,CARf,CATA;AAmBJ4B,IAAAA,OAAO,EAAE;AACLf,MAAAA,OAAO,EAAE,QADJ;AAELC,MAAAA,MAAM,EAAE;AACJK,QAAAA,MAAM,EAAE;AACJC,UAAAA,KAAK,EAAEvB,IAAI,CAAE4B,OAAD,KAAc;AACtBI,YAAAA,IAAI,EAAE,OADgB;AAEtBC,YAAAA,KAAK,eAAQL,OAAO,CAACC,KAAhB;AAFiB,WAAd,CAAD;AADP;AADJ;AAFH;AAnBL;AAFyD,CAA9D","sourcesContent":["import { MachineConfig, send, assign } from \"xstate\";\nimport {say, listen, promptAndAsk } from \"./index\";\nimport { loadGrammar } from './runparser'\nimport { parse } from './chartparser'\nimport { grammar } from './grammars/orderGrammar'\n\nconst gram = loadGrammar(grammar)\n\nconst Order = (input: string) => {\n    const gram = loadGrammar(grammar);\n    const prs = parse(input.split(/\\s+/), gram);\n    const result = prs.resultsForRule(gram.$root)[0]\n    // const reply = console.log(result)\n    return result\n}\n\n\n// <tag>out.order= new Object(); out.order.object = rules.order.entity; out.order.event = rules.order.action; out.order.transition=rules.order.transition;</tag>\nexport const dmMachine4: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    states: {\n        idle: {},\n        welcome: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"task\" },\n            states: {\n                prompt: { entry: say(\"Welcome to Smart Home\") }\n            }\n        },\n        task: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: {\n                    target: 'perform',\n                    actions: assign((context) => {return { order: Order(context.recResult) } })\n                        }\n                    },\n            ...promptAndAsk(\"I await for your orders.\")\n        },\n        perform: {\n            initial: \"prompt\",\n            states: {\n                prompt: { \n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK ${context.order}.`\n                    }))\n                }\n            }\n        }\n    }\n})"]},"metadata":{},"sourceType":"module"}