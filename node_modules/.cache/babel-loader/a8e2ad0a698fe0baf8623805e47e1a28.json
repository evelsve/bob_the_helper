{"ast":null,"code":"import _objectSpread from \"/Users/evelsve/repos/react-xstate-colourchanger/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { send, assign } from \"xstate\";\nimport { say, promptAndAsk } from \"./index\";\nimport { loadGrammar } from './runparser';\nimport { parse } from './chartparser';\nimport { grammar } from './grammars/orderGrammar';\nconst gram = loadGrammar(grammar);\n\nconst Order = input => {\n  const gram = loadGrammar(grammar);\n  const prs = parse(input.split(/\\s+/), gram);\n  const result = prs.resultsForRule(gram.$root)[0];\n  const answer = result.order.action + result.order.object;\n  return answer;\n}; // <tag>out.order= new Object(); out.order.object = rules.order.entity; out.order.event = rules.order.action; out.order.transition=rules.order.transition;</tag>\n\n\n_c = Order;\nexport const dmMachine4 = {\n  initial: 'idle',\n  states: {\n    idle: {},\n    welcome: {\n      initial: \"prompt\",\n      on: {\n        ENDSPEECH: \"task\"\n      },\n      states: {\n        prompt: {\n          entry: say(\"Welcome to Smart Home\")\n        }\n      }\n    },\n    task: _objectSpread({\n      initial: \"prompt\",\n      on: {\n        RECOGNISED: [{\n          cond: context => {\n            return {\n              order: Order(context.recResult)\n            } !== undefined;\n          },\n          actions: assign(context => {\n            return {\n              order: Order(context.recResult)\n            } || {};\n          }),\n          target: 'perform'\n        }, {\n          target: \"perform.nomatch\"\n        }]\n      }\n    }, promptAndAsk(\"I await for your orders.\")),\n    perform: {\n      initial: \"prompt\",\n      states: {\n        prompt: {\n          entry: send(context => ({\n            type: \"SPEAK\",\n            value: \"The task \".concat(context.order, \" has been accomplished\")\n          }))\n        },\n        nomatch: {\n          entry: say(\"Sorry, I do not understand\"),\n          on: {\n            ENDSPEECH: \"prompt\"\n          }\n        }\n      }\n    }\n  }\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"Order\");","map":{"version":3,"sources":["/Users/evelsve/repos/react-xstate-colourchanger/src/dmSmartHome.ts"],"names":["send","assign","say","promptAndAsk","loadGrammar","parse","grammar","gram","Order","input","prs","split","result","resultsForRule","$root","answer","order","action","object","dmMachine4","initial","states","idle","welcome","on","ENDSPEECH","prompt","entry","task","RECOGNISED","cond","context","recResult","undefined","actions","target","perform","type","value","nomatch"],"mappings":";AAAA,SAAwBA,IAAxB,EAA8BC,MAA9B,QAA4C,QAA5C;AACA,SAAQC,GAAR,EAAqBC,YAArB,QAAyC,SAAzC;AACA,SAASC,WAAT,QAA4B,aAA5B;AACA,SAASC,KAAT,QAAsB,eAAtB;AACA,SAASC,OAAT,QAAwB,yBAAxB;AAEA,MAAMC,IAAI,GAAGH,WAAW,CAACE,OAAD,CAAxB;;AAEA,MAAME,KAAK,GAAIC,KAAD,IAAmB;AAC7B,QAAMF,IAAI,GAAGH,WAAW,CAACE,OAAD,CAAxB;AACA,QAAMI,GAAG,GAAGL,KAAK,CAACI,KAAK,CAACE,KAAN,CAAY,KAAZ,CAAD,EAAqBJ,IAArB,CAAjB;AACA,QAAMK,MAAM,GAAGF,GAAG,CAACG,cAAJ,CAAmBN,IAAI,CAACO,KAAxB,EAA+B,CAA/B,CAAf;AACA,QAAMC,MAAM,GAAGH,MAAM,CAACI,KAAP,CAAaC,MAAb,GAAsBL,MAAM,CAACI,KAAP,CAAaE,MAAlD;AACA,SAAOH,MAAP;AACH,CAND,C,CAUA;;;KAVMP,K;AAWN,OAAO,MAAMW,UAAoD,GAAI;AACjEC,EAAAA,OAAO,EAAE,MADwD;AAEjEC,EAAAA,MAAM,EAAE;AACJC,IAAAA,IAAI,EAAE,EADF;AAEJC,IAAAA,OAAO,EAAE;AACLH,MAAAA,OAAO,EAAE,QADJ;AAELI,MAAAA,EAAE,EAAE;AAAEC,QAAAA,SAAS,EAAE;AAAb,OAFC;AAGLJ,MAAAA,MAAM,EAAE;AACJK,QAAAA,MAAM,EAAE;AAAEC,UAAAA,KAAK,EAAEzB,GAAG,CAAC,uBAAD;AAAZ;AADJ;AAHH,KAFL;AASJ0B,IAAAA,IAAI;AACAR,MAAAA,OAAO,EAAE,QADT;AAEAI,MAAAA,EAAE,EAAE;AACAK,QAAAA,UAAU,EAAE,CACR;AACAC,UAAAA,IAAI,EAAGC,OAAD,IAAa;AAAC,mBAAO;AAAEf,cAAAA,KAAK,EAAER,KAAK,CAACuB,OAAO,CAACC,SAAT;AAAd,kBAAwCC,SAA/C;AAAyD,WAD7E;AAEAC,UAAAA,OAAO,EAAEjC,MAAM,CAAE8B,OAAD,IAAa;AAAC,mBAAO;AAAEf,cAAAA,KAAK,EAAER,KAAK,CAACuB,OAAO,CAACC,SAAT;AAAd,iBAAuC,EAA9C;AAAiD,WAAhE,CAFf;AAGAG,UAAAA,MAAM,EAAE;AAHR,SADQ,EAMR;AAAEA,UAAAA,MAAM,EAAE;AAAV,SANQ;AADZ;AAFJ,OAaGhC,YAAY,CAAC,0BAAD,CAbf,CATA;AAwBJiC,IAAAA,OAAO,EAAE;AACLhB,MAAAA,OAAO,EAAE,QADJ;AAELC,MAAAA,MAAM,EAAE;AACJK,QAAAA,MAAM,EACF;AACAC,UAAAA,KAAK,EAAE3B,IAAI,CAAE+B,OAAD,KAAc;AAACM,YAAAA,IAAI,EAAE,OAAP;AAAgBC,YAAAA,KAAK,qBAAcP,OAAO,CAACf,KAAtB;AAArB,WAAd,CAAD;AADX,SAFA;AAKJuB,QAAAA,OAAO,EAAE;AACLZ,UAAAA,KAAK,EAAEzB,GAAG,CAAC,4BAAD,CADL;AAELsB,UAAAA,EAAE,EAAE;AAAEC,YAAAA,SAAS,EAAE;AAAb;AAFC;AALL;AAFH;AAxBL;AAFyD,CAA9D","sourcesContent":["import { MachineConfig, send, assign } from \"xstate\";\nimport {say, listen, promptAndAsk } from \"./index\";\nimport { loadGrammar } from './runparser'\nimport { parse } from './chartparser'\nimport { grammar } from './grammars/orderGrammar'\n\nconst gram = loadGrammar(grammar)\n\nconst Order = (input: string) => {\n    const gram = loadGrammar(grammar);\n    const prs = parse(input.split(/\\s+/), gram);\n    const result = prs.resultsForRule(gram.$root)[0]\n    const answer = result.order.action + result.order.object;\n    return answer\n}\n\n\n\n// <tag>out.order= new Object(); out.order.object = rules.order.entity; out.order.event = rules.order.action; out.order.transition=rules.order.transition;</tag>\nexport const dmMachine4: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    states: {\n        idle: {},\n        welcome: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"task\" },\n            states: {\n                prompt: { entry: say(\"Welcome to Smart Home\") }\n            }\n        },\n        task: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                    {\n                    cond: (context) => {return { order: Order(context.recResult) } !== undefined},\n                    actions: assign((context) => {return { order: Order(context.recResult) } || {}}),\n                    target: 'perform'\n                    },\n                    { target: \"perform.nomatch\" }\n                    ]\n                     \n                },\n            ...promptAndAsk(\"I await for your orders.\")\n        },\n        perform: {\n            initial: \"prompt\",\n            states: {\n                prompt: \n                    { \n                    entry: send((context) => ({type: \"SPEAK\", value: `The task ${context.order} has been accomplished`}))\n                    },\n                nomatch: {\n                    entry: say(\"Sorry, I do not understand\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                    }\n            }\n            }\n        }\n    }\n)"]},"metadata":{},"sourceType":"module"}